# 基本思路
`Linux`内核提供了`tun/tap`机制允许开发者拦截操作系统流量，`tun`位于`OSI`五层网络模型的`IP`层。通过`/dev/tun`可以获取所有网络协议流量，应用程序处理完成后回写`/dev/tun`即完成了网络代理。

在`Android`系统上提供了`VpnService`，可以通过配置网卡ip、路由、以及绕行规则来启动一个`tun`设备，应用层拿到的是一个`FileDescriptor`，对此`fd`进行`read`可拿到`ip`包，对此`fd`进行`write`可以对应用程序网络请求进行回复。

将拿到的`fd`透传给`tun2socks`可以完成`IP`数据报到`socks`代理请求的转换，`tun2socks`内部处理了`TCP`协议、`UDP`协议的封装和转发，应用程序内部需要实现一个`socks5`代理服务器，用于接收和处理`tun2socks`程序转发过来的`socks5`代理请求。

`socks5`协议可以代理`TCP`和`UDP`流量。[RFC1928中文文档](https://www.quarkay.com/code/383/socks5-protocol-rfc-chinese-traslation)

建立连接初期，`socks5`通过`TCP`连接将握手请求发送至服务器，由服务器处理请求并响应`socks5`客户端。

* socks5握手过程：
	1、客户端发送`socks`版本号以及鉴权方法
	2、服务端验证版本号以及鉴权方法
	3、客户端发送鉴权请求
	4、服务端处理鉴权请求并回复客户端
	5、客户端发送`socks5`请求命令、目标地址、端口
	6、服务端解析请求命令、目标地址然后连接远程代理服务器并响应`socks5`客户端，这个服务器可以是下一级代理服务器，也可以是真实目标服务器。

其中`CMD`分为`CONNECT`、`BIND`、`UDP ASSOCIATE`

对于`CONNECT`一旦第三次握手成功就可以开始代理客户端流量。
对于`BIND`需要在本地起一个`tcp` `socket`监听来自远程服务器的请求，当远程服务器成功连接时，将远程服务器地址和端口写入缓冲区并响应客户端，此时就建立了一个远程服务器和本地`socks5`客户端的连接。
对于`UDP`需要起一个`UDP` `server socket`用来转发`socks5`客户端的`UDP`请求，这个`UDP` `server socket`，以及这个`UDP` `server socket`所关联的所有`UDP` `socket`生命周期都与发起`UDP`请求的`socks5` `TCP`请求的生命周期绑定。

# 数据转发通道的实现：
`socket`数据转发通道通常包含入站和出站两个角色，对于代理服务器来讲，入站代表连接`socks5`客户端的那一端，出站代表连接远程服务器的那一端。通道内通过事件循环机制来监听这两端的`fd`的读写。通常对于面向流的协议,如`TCP`，可以利用两个适当大小的环形缓冲区作为读写缓冲区，这样来说可以避免频繁分配和释放内存，也可以实现全双工的数据转发。对于UDP协议，应当提供一个尽可能大的缓冲区，避免`UDP`分片和重组的发生。

# 密码学相关概念：

代理数据传输通常需要考虑到数据安全问题，关于数据安全传输，可以大概了解一下。最典型的数据安全传输方案就是`SSL/TLS`。

1、哈希函数，如`SHA-256`，`SHA3`，`RIPEMD`
2、消息认证码`MAC`，散列消息认证码`HMAC`
3、密钥派生函数`KDF`，如`Scrypt`，`Argon2`
4、密钥交换算法，如`Diffie-Hellman`密钥交换协议
5、对称加密，如`AES`，`AES-256-GCM`，`Chacha20`
6、非对称加密，如`RSA`、`ECC（椭圆曲线）`
7、数字签名算法，如`ECDSA`
8、熵与随机数生成器
9、量子安全

这个博客总结的非常详细：https://thiscute.world/posts/practical-cryptography-basics-1/

### 密码学用途：
1、加密与解密
2、数字签名与消息认证
3、安全随机数
4、密钥交换
5、加密哈希与password哈希
6、混淆与扩散
7、密码库

* 哈希函数又叫散列函数，是从任何一条消息中创建数字指纹，也叫数字摘要的方法。散列函数把消息方法或缩小到一个固定的长度。一个优秀的哈希函数应该是快速的、确定的、难以分析的、不可逆的、无碰撞的。

* 量子安全概念：现代密码学哈希函数（`SHA2`，`SHA3`，`BLAKE2`）被认为是量子安全的，是量子计算机也无法攻破的。

* 哈希的用途有：完整性校验、唯一ID、保存密码、伪随机数生成。

* `MAC`函数用于确保数据的真实性以及完整性，一般实现为`HMAC`，即基于哈希函数实现的`MAC`算法，它比普通哈希算法多一个密钥参数。

* 数字签名使用非对称加密算法实现，更复杂，计算速度也更慢；`MAC`使用哈希算法或者对称加密算法实现，速度更快，实现更简单。

* 常用的加密方法只能保证保密性，而不能保证完整性、真实性。

* 认证加密（`AE`）就是将加密算法与`MAC`算法结合的一种方案。在确保`MAC`码不可伪造的前提下，同时计算`MAC`码，同加密数据一同传输。

* 带有关联数据的认证加密（AEAD）：

	`PRNG`（伪随机数生成器）用来生成伪随机数，伪随机数的生成依赖操作系统提供的种子，如果种子是不可预测的，那么生成的伪随机数就是不可预测的。

	`CSPRNG`（密码学安全随机数生成器）：适用于密码学领域的随机数生成器。

* 操作系统通过收集内部熵产生随机数。

	`Linux`提供`/dev/random`（受阻塞的随机数生成器）,`/dev/urandom`（不受阻塞的随机数生成器）。

* 密钥交换是一种协议，用于在通信的双方安全地交换加密密钥。

	密钥交换有两种方案：
	密钥协商：双方都参与密钥生成，两个代表算法是`Diffie-Hellman（DHKE）`和`Elliptic-Curive Diffie-Hellman（ECDH）`。
	密钥传输：其中一方生成密钥，并通过传输将密钥传输给另一方。通常通过非对称加密。

* 认证密钥交换协议：同时认证身份的密钥交换协议。

* 对称加密常见的算法有：`AES(AES-128,AES-192,AES-256)`，`Chacha20`，`RC6`，`Twofish`等。

* 对称加密又分为块密码和流密码，块密码只对固定大小的数据加密，而流密码作用于字节流，可以对每个字节加密。

* 对称加密算法只能保证安全性，而不能保证真实性，完整性，与不可否认性。所以我们通常将对称加密算法和其他算法组成一个对称加密方案，通常包含以下：
	1、将密码转换为密钥的密钥派生算法`KDF`
	2、分组密码工作模式（`ECB`，`CBC`，`CTR`，`GCM`，`CFB`等）+消息填充算法（`PKCS7`）
	3、分组密码算法，如`AES`
	4、消息认证算法，如`HMAC`

* 初始向量（`IV`）用于向密文中添加随机性，使得相同的明文被多次加密也不会产生相同的密文，从而确保密文的不可预测性。有时也被称为`salt`或者`nonce`。
